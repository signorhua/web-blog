### 什么是正则表达式
+ 正则表达式是对字符串操作的一种逻辑公式，描述了一种字符串匹配的模式

### 正则表达式有什么用
+ 可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串

### 正则表达式怎么用
+ js中通过内置对象RegExp支持正则表达式
    + var reg = //; 字面量
    + var reg = new Reg(); 构造函数

+ 简答使用
  ```js
    var reg = /\bis\b/; // 把字符串中第一个的is找出来，\b标识表示单词边界
    var reg = new Reg('\\bis\\b'); // 这里因为要发现有两个反斜线，因为需要转义
  ```
+ 修饰符使用
  ```js
    var reg = /\bis\b/i; // i代表忽略掉大小写，都可以一起选中Is is iS
    var reg = new Reg('\\bis\\b','i');
  ```
  - g 全局模式， i 忽略大小写， m 多行模式（把换行符也当成新的一行，^边界符可以匹配上

+ 元字符
    - 正则表达式有两种<strong>基本字符类型</strong>组成
    - 原义文本字符 代表它本来意思的字符 a就代表a
    - 元字符  正则表达式中有特殊含义的非字母字符
    ```js
        var reg = /\bis\b/; // 在这里\b就是一个元字符，代表的含义是单词边界
        var reg = /ab\t/;  // 在这里\t 的含义就是代表一个水平制表符
    ```

+ 字符类 
    - 使用元字符[]来构建一个简单的类
    - 所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符
    - 表达式[abc]把字符a 或 b 或 c 归为一个类，表达式可以匹配这一类的字符
    - 反向类 [^abc] 不属于这个类的字符

+ 范围类
    - 定义一个范围 [a-z] a-z 26个小写字母
    - 两个范围可以连着写[a-zA-Z] 26个大写字母和26个小写字母

+ 预定义类
    - 正则表达式定义了一些常见的字符类 

        | 预定义类 | 等价类 | 含义 |
        | --- | ---| --- |
        | . | [^\r\n] | 除了回车和换行符之外的所有字符|
        | \d | [0-9] | 数字字符 |
        | \D | [^0-9] | 非数字字符 |
        | \s | [\t\n\x0B\f\r] | 空白字符 |
        | \w | [a-zA-Z_0-9] | 单词字符 | 
    - 小写的预定义类和大写的预定义类，刚好是反向类的关系
    ```js
    var reg = /ab\d./; // ab + 数字 + 任意字符
    ```
 + 边界匹配字符

    | 字符 | 含义 | 
    | --- | ---| 
    | ^ | 以xxx开始的 | 
    | $ | 以xxx结束的 |
    ```js
        var reg = /^start/; // 以start开头的
    ```
+ 量词 {}

    + 标识数量的字符

    | 字符 | 含义 | 
    | --- | ---| 
    | ? | 出现零次或一次，最多出现一次 | 
    | + | 出现一次或多次，至少出现一次 |
    | * | 出现零次或多次，任意次 |
    | {n} | 出现n次 |
    | {n,m} | 出现 n 到 m 次 |
    | {n,} | 至少出现n次 |
    ```js
        var reg = /\d*/ //任意次
    ```
+ 贪婪模式 {}?
    - 正则表达式 会向多的匹配 ，也就是默认的贪婪模式
        ```js
        var reg = /\d{3,6}/; // 会尽量去匹配出现6次数字的情况
        var str = '12345678'.replace(reg,'Q'); // Q78
        ```
    + 非贪婪模式，在量词后面添加?
        ```js
        var reg = /\d{3,6}?/; //  匹配到就会返回
        var str = '12345678'.replace(reg,'Q'); // Q45678
        ```
+ 分组 （）{}
    - 让量词作用在一段 文字中，而不是紧挨着的那个字符
        ```js
        var reg = /(abc){1,3}/; // 123 连续出现1到3次
        ```
+ 或 | 可配合分组使用
    ```js
        var reg = /ab(cd|ef)gg/; // abcdgg 或者 abefgg两种情况都能匹配得到
    ```
+ 反向引用
    - 利用$来反向引用 捕获每一个分组
    ```js
        var str = '2015-08-09';
        var reg = /(\d{4})-(\d{2})-(\d{2})/;
        str.replace(reg,'$3/$2/$1');
    ```
    - 反向引用 忽略分组 不会捕获到 (? : 组内容)
    ```js
        var reg = '/(? : abc)/'; // abc这个组反向引用 无法捕获
    ```
+ 前瞻
    - 从前面开始解析 后瞻从后面开始解析   js没有后瞻
    - 匹配到规则的时候，向前检测是否符合断言，其实就是多加一道判断，但是不在匹配项目里面
    - 符合断言和不符合断言的情况，称为正向和负向
    - 前瞻正向 exp(?=assert) 从前面开始匹配，匹配项后面必须符合断言要求
    - 前瞻负向 exp(?!assert) 从前面开始匹配，匹配项后面必须不符合断言要求
+ 正则表达式对象的属性
    - global 返回是否设置该修饰符
    - multiline 同上
    - ignoreCase 同上
    - source 返回正则表达式的字符
    - lastIndex 返回表达式匹配内容的最后一个字符的下一个位置
+ 正则表达式对象的方法
    - text  是否匹配上 reg.test(str); 返回true和false
        ```js
            var str = 'abc';
            var reg = /\w/;
            reg.test(str); // true 执行多少遍都是一样的
            var reg2 = /\w/g;
            reg2.test(str); // 执行多几遍，会变成false，设置global修饰符原因是因为lastindex属性会变化
        ```
    - exec 
        + g修饰符下调用，返回是否匹配上
            * 匹配上了返回一个数组，第一项匹配中的字符，index属性位置，input属性匹配字符串，返回一个分组
            * 匹配不上 返回一个null
        + 没有使用g修饰符
            * 匹配上了返回一个数组，在g修饰符的返回数组中，第一项和第二项中间多加一项
        + 待补充修复
+ 字符串方法
    - str.search(reg);返回第一个匹配结果index，查找不到返回-1，也可以传入字符串，也可以传入数字会转换成字符串，同时会忽略掉g，只会找到第一个
    - str.match(reg);返回一个或多个匹配的文本，和g修饰符相关较大
    - str.replace(reg,str); 替换
        - str.replace(reg,fun); 匹配到一次，就调用一次
        - fun的至少3个参数 1.匹配字符串 2.正则表达式分组内容，没有分组则没有该参数，有几个分组就有几个参数
        - 3.匹配项在字符串中的index
        - 4.原字符串

